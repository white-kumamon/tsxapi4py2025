<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>TSX DOM Surface Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0f172a;
        --bg-elevated: #111c34;
        --text: #e2e8f0;
        --accent: #38bdf8;
        --warning: #f97316;
        --error: #f87171;
        --success: #34d399;
        font-family: 'Segoe UI', 'Helvetica Neue', 'Hiragino Sans', 'Noto Sans JP', sans-serif;
      }

      body {
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 1.2rem 1.8rem;
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        gap: 1rem;
        background: rgba(15, 23, 42, 0.9);
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(12px);
      }

      header h1 {
        margin: 0;
        font-size: 1.4rem;
        font-weight: 600;
        letter-spacing: 0.05em;
      }

      .status-chip {
        padding: 0.3rem 0.8rem;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid rgba(59, 130, 246, 0.4);
      }

      .status-chip[data-state="CONNECTED"] {
        background: rgba(52, 211, 153, 0.2);
        border-color: rgba(52, 211, 153, 0.4);
      }

      .status-chip[data-state="ERROR"],
      .status-chip[data-state="ERROR"] {
        background: rgba(248, 113, 113, 0.25);
        border-color: rgba(248, 113, 113, 0.4);
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 2.2fr) minmax(0, 1fr);
        gap: 1.5rem;
        padding: 1.5rem;
      }

      section {
        background: var(--bg-elevated);
        border-radius: 1rem;
        padding: 1.2rem;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        border: 1px solid rgba(148, 163, 184, 0.08);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        min-height: 0;
      }

      section h2 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        opacity: 0.8;
      }

      .chart-container {
        flex: 1;
        min-height: 240px;
      }

      #price-chart {
        width: 100%;
        height: 100%;
      }

      #dom-surface {
        width: 100%;
        height: 320px;
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.8rem;
      }

      .status-card {
        background: rgba(148, 163, 184, 0.08);
        border-radius: 0.75rem;
        padding: 0.85rem 1rem;
        border: 1px solid rgba(148, 163, 184, 0.12);
      }

      .status-card dt {
        font-size: 0.75rem;
        opacity: 0.7;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        margin-bottom: 0.35rem;
      }

      .status-card dd {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .depth-lists {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 1rem;
      }

      .depth-list h3 {
        margin: 0 0 0.6rem;
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        opacity: 0.8;
      }

      .depth-list ul {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.4rem;
      }

      .depth-list li {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.6rem;
        padding: 0.45rem 0.6rem;
        border-radius: 0.6rem;
        background: rgba(15, 23, 42, 0.45);
        border: 1px solid rgba(148, 163, 184, 0.08);
        font-size: 0.9rem;
      }

      .depth-list li.volume-20 {
        color: #f8fafc;
      }

      .depth-list li.volume-50 {
        color: #fb923c;
      }

      .depth-list li.volume-100 {
        color: #facc15;
      }

      .depth-list li span.price {
        font-variant-numeric: tabular-nums;
      }

      .depth-list li span.volume {
        text-align: right;
        font-variant-numeric: tabular-nums;
      }

      footer {
        padding: 0.9rem 1.5rem;
        font-size: 0.75rem;
        opacity: 0.6;
        letter-spacing: 0.08em;
      }

      @media (max-width: 1100px) {
        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>TSX DOM Surface Dashboard</h1>
      <div class="status-chip" id="connection-state" data-state="INIT">INIT</div>
    </header>
    <main>
      <section>
        <h2>Price &amp; Volume</h2>
        <div class="chart-container">
          <div id="price-chart"></div>
        </div>
        <dl class="status-grid">
          <div class="status-card">
            <dt>Contract</dt>
            <dd id="status-contract">—</dd>
          </div>
          <div class="status-card">
            <dt>Last Trade</dt>
            <dd id="status-last-price">—</dd>
          </div>
          <div class="status-card">
            <dt>Bid / Ask</dt>
            <dd id="status-bid-ask">—</dd>
          </div>
          <div class="status-card">
            <dt>Updated</dt>
            <dd id="status-updated">—</dd>
          </div>
        </dl>
      </section>
      <section>
        <h2>DOM Surface &amp; Order Book</h2>
        <div class="chart-container" style="min-height: 320px;">
          <div id="dom-surface"></div>
        </div>
        <div class="depth-lists">
          <div class="depth-list">
            <h3>Bids</h3>
            <ul id="depth-bids"></ul>
          </div>
          <div class="depth-list">
            <h3>Asks</h3>
            <ul id="depth-asks"></ul>
          </div>
        </div>
      </section>
    </main>
    <footer>
      SignalR stream is proxied via FastAPI. Refresh the browser if connection is lost for a prolonged period.
    </footer>

    <script>
      const priceChart = document.getElementById('price-chart');
      const domSurface = document.getElementById('dom-surface');
      const connectionChip = document.getElementById('connection-state');
      const contractEl = document.getElementById('status-contract');
      const lastPriceEl = document.getElementById('status-last-price');
      const bidAskEl = document.getElementById('status-bid-ask');
      const updatedEl = document.getElementById('status-updated');
      const depthBidsEl = document.getElementById('depth-bids');
      const depthAsksEl = document.getElementById('depth-asks');

      let priceInitialised = false;
      let domInitialised = false;
      let ws;
      let retryCount = 0;

      function normalisePrice(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return null;
        return Math.round(numeric);
      }

      function classifyDepthVolume(volume) {
        const numeric = Number(volume ?? 0);
        if (!Number.isFinite(numeric)) return null;
        if (numeric >= 100) return 'volume-100';
        if (numeric >= 50) return 'volume-50';
        if (numeric >= 20) return 'volume-20';
        return null;
      }

      function depthFillColor(volume) {
        const numeric = Number(volume ?? 0);
        if (!Number.isFinite(numeric)) return 'rgba(148, 163, 184, 0.1)';
        if (numeric >= 100) return 'rgba(250, 204, 21, 0.35)';
        if (numeric >= 50) return 'rgba(249, 115, 22, 0.3)';
        if (numeric >= 20) return 'rgba(255, 255, 255, 0.25)';
        return 'rgba(148, 163, 184, 0.12)';
      }

      function buildDomShapes(orderBook) {
        const shapes = [];
        const bids = orderBook?.bids ?? [];
        const asks = orderBook?.asks ?? [];
        const band = 0.45;

        for (const level of bids) {
          const price = normalisePrice(level?.price);
          if (price == null) continue;
          const fillcolor = depthFillColor(level?.volume);
          shapes.push({
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0,
            x1: 0.48,
            y0: price - band,
            y1: price + band,
            line: { width: 0 },
            fillcolor,
            opacity: 1,
          });
        }

        for (const level of asks) {
          const price = normalisePrice(level?.price);
          if (price == null) continue;
          const fillcolor = depthFillColor(level?.volume);
          shapes.push({
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0.52,
            x1: 1,
            y0: price - band,
            y1: price + band,
            line: { width: 0 },
            fillcolor,
            opacity: 1,
          });
        }

        return shapes;
      }

      function initCharts() {
        if (!priceInitialised) {
          const baseLayout = {
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(17,28,52,0.7)',
            margin: { t: 30, l: 50, r: 10, b: 40 },
            xaxis: { title: 'Time', type: 'date', gridcolor: 'rgba(148,163,184,0.15)' },
            yaxis: {
              title: 'Price',
              gridcolor: 'rgba(148,163,184,0.15)',
              tickformat: ',.0f',
              hoverformat: ',.0f',
              dtick: 1,
            },
            legend: { orientation: 'h', xanchor: 'center', x: 0.5, y: 1.1 },
          };

          Plotly.newPlot(
            priceChart,
            [
              {
                name: 'Price',
                mode: 'lines',
                line: { color: '#38bdf8', width: 2 },
                x: [],
                y: [],
              },
              {
                name: 'Volume',
                mode: 'markers',
                marker: {
                  color: '#f97316',
                  sizemode: 'area',
                  sizeref: 2,
                  sizemin: 4,
                  opacity: 0.7,
                },
                x: [],
                y: [],
                text: [],
              },
            ],
            baseLayout,
            { responsive: true, displaylogo: false }
          );
          priceInitialised = true;
        }

        if (!domInitialised) {
          Plotly.newPlot(
            domSurface,
            [
              {
                type: 'heatmap',
                z: [[], []],
                x: [],
                y: ['Bids', 'Asks'],
                colorscale: 'Portland',
                showscale: true,
                hovertemplate: '価格: %{x:.0f}<br>出来高: %{z}<extra></extra>',
              },
            ],
            {
              paper_bgcolor: 'rgba(0,0,0,0)',
              plot_bgcolor: 'rgba(17,28,52,0.7)',
              margin: { t: 30, l: 60, r: 10, b: 40 },
              xaxis: {
                title: 'Price',
                gridcolor: 'rgba(148,163,184,0.15)',
                tickformat: ',.0f',
                hoverformat: ',.0f',
              },
              yaxis: { title: '', gridcolor: 'rgba(148,163,184,0.15)' },
            },
            { responsive: true, displaylogo: false }
          );
          domInitialised = true;
        }
      }

      function updateConnectionState(stateText) {
        connectionChip.textContent = stateText;
        connectionChip.dataset.state = stateText;
      }

      function updatePriceChart(payload) {
        const trades = payload.trades ?? [];
        const bubbles = payload.volume_bubbles ?? [];
        const orderBook = payload.order_book ?? { bids: [], asks: [] };

        const x = trades.map((t) => new Date(t.timestamp));
        const y = trades.map((t) => normalisePrice(t.price));

        const bubbleX = bubbles.map((t) => new Date(t.timestamp));
        const bubbleY = bubbles.map((t) => normalisePrice(t.price));
        const bubbleSize = bubbles.map((t) => Math.max(Number(t.volume ?? 0), 0));
        const bubbleText = bubbles.map(
          (t) => `価格: ${formatPrice(t.price)}<br>出来高: ${formatVolume(t.volume)}`
        );

        const layout = {
          ...(priceChart.layout ?? {}),
          yaxis: {
            ...(priceChart.layout?.yaxis ?? {}),
            tickformat: ',.0f',
            hoverformat: ',.0f',
            dtick: 1,
          },
          shapes: buildDomShapes(orderBook),
        };

        Plotly.react(
          priceChart,
          [
            {
              name: 'Price',
              mode: 'lines',
              line: { color: '#38bdf8', width: 2 },
              x,
              y,
              hovertemplate: '価格: %{y:.0f}<br>時間: %{x|%H:%M:%S}<extra></extra>',
            },
            {
              name: 'Volume',
              mode: 'markers',
              marker: {
                color: '#f97316',
                sizemode: 'area',
                sizeref: bubbleSize.length ? Math.max(...bubbleSize) / 120 : 2,
                sizemin: 4,
                opacity: 0.7,
                line: { color: '#0f172a', width: 1 },
                size: bubbleSize,
              },
              x: bubbleX,
              y: bubbleY,
              text: bubbleText,
              hovertemplate: '%{text}<extra></extra>',
            },
          ],
          layout
        );
      }

      function updateDomSurface(payload) {
        const orderBook = payload.order_book ?? { bids: [], asks: [] };
        const bids = Array.isArray(orderBook.bids) ? [...orderBook.bids] : [];
        const asks = Array.isArray(orderBook.asks) ? [...orderBook.asks] : [];

        const processedBids = bids
          .map((b) => {
            const volume = Number(b.volume ?? 0);
            return {
              ...b,
              price: normalisePrice(b.price),
              volume: Number.isFinite(volume) ? volume : 0,
            };
          })
          .filter((b) => b.price != null);
        const processedAsks = asks
          .map((a) => {
            const volume = Number(a.volume ?? 0);
            return {
              ...a,
              price: normalisePrice(a.price),
              volume: Number.isFinite(volume) ? volume : 0,
            };
          })
          .filter((a) => a.price != null);

        const reversedBids = [...processedBids].reverse();

        const priceLevels = [
          ...reversedBids.map((b) => b.price),
          ...processedAsks.map((a) => a.price),
        ];
        const bidsVolumes = [
          ...reversedBids.map((b) => Math.max(b.volume, 0)),
          ...new Array(processedAsks.length).fill(null),
        ];
        const asksVolumes = [
          ...new Array(reversedBids.length).fill(null),
          ...processedAsks.map((a) => Math.max(a.volume, 0)),
        ];

        const domLayout = {
          ...(domSurface.layout ?? {}),
          xaxis: {
            ...(domSurface.layout?.xaxis ?? {}),
            tickformat: ',.0f',
            hoverformat: ',.0f',
          },
        };

        Plotly.react(
          domSurface,
          [
            {
              type: 'heatmap',
              z: [bidsVolumes, asksVolumes],
              x: priceLevels,
              y: ['Bids', 'Asks'],
              colorscale: 'Portland',
              showscale: true,
              hovertemplate: '価格: %{x:.0f}<br>出来高: %{z}<extra></extra>',
            },
          ],
          domLayout
        );

        const bidItems = reversedBids
          .map((b) => {
            const cls = classifyDepthVolume(b.volume);
            const classAttr = cls ? ` class="${cls}"` : '';
            return `<li${classAttr}><span class="price">${formatPrice(b.price)}</span><span class="volume">${formatVolume(b.volume)}</span></li>`;
          })
          .join('');
        const askItems = processedAsks
          .map((a) => {
            const cls = classifyDepthVolume(a.volume);
            const classAttr = cls ? ` class="${cls}"` : '';
            return `<li${classAttr}><span class="price">${formatPrice(a.price)}</span><span class="volume">${formatVolume(a.volume)}</span></li>`;
          })
          .join('');

        depthBidsEl.innerHTML = bidItems || '<li>—</li>';
        depthAsksEl.innerHTML = askItems || '<li>—</li>';
      }

      function formatPrice(value) {
        const normalised = normalisePrice(value);
        if (normalised == null) return '—';
        return normalised.toLocaleString(undefined, { maximumFractionDigits: 0 });
      }

      function formatVolume(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return '—';
        return Math.max(numeric, 0).toLocaleString(undefined, { maximumFractionDigits: 2 });
      }

      function updateStatus(payload) {
        contractEl.textContent = payload.contract_id ?? '—';
        updatedEl.textContent = payload.last_update ? new Date(payload.last_update).toLocaleTimeString() : '—';
        updateConnectionState(payload.state ?? 'UNKNOWN');

        const quote = payload.quote ?? {};
        const lastPrice = quote.last ?? (payload.trades?.at(-1)?.price ?? null);
        lastPriceEl.textContent = lastPrice != null ? formatPrice(lastPrice) : '—';
        bidAskEl.textContent = quote.bid != null && quote.ask != null
          ? `${formatPrice(quote.bid)} / ${formatPrice(quote.ask)}`
          : '—';
      }

      function handleSnapshot(payload) {
        updateStatus(payload);
        updatePriceChart(payload);
        updateDomSurface(payload);
      }

      function connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        ws = new WebSocket(`${protocol}://${window.location.host}/ws`);

        ws.onopen = () => {
          retryCount = 0;
          updateConnectionState('CONNECTED');
        };

        ws.onmessage = (event) => {
          const payload = JSON.parse(event.data);
          handleSnapshot(payload);
        };

        ws.onclose = () => {
          updateConnectionState('DISCONNECTED');
          if (retryCount < 10) {
            const timeout = Math.min(1000 * Math.pow(2, retryCount), 15000);
            retryCount += 1;
            setTimeout(connectWebSocket, timeout);
          }
        };

        ws.onerror = () => {
          updateConnectionState('ERROR');
          ws.close();
        };
      }

      initCharts();
      connectWebSocket();
    </script>
  </body>
</html>

